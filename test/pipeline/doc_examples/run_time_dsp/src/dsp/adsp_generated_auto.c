
#include <stages/adsp_pipeline.h>
#include <stages/adsp_control.h>
#include <xcore/select.h>
#include <xcore/channel.h>
#include <xcore/assert.h>
#include <xcore/hwtimer.h>
#include <xcore/thread.h>
#include <print.h>
#include "cmds.h" // Autogenerated
#include "cmd_offsets.h" // Autogenerated
#include <stages/bump_allocator.h>
#include <dsp/signal_chain.h>

// used in print_max_ticks
static adsp_controller_t* m_control;
#include <stages/pipeline.h>
#include <stages/dsp_thread.h>
#include <stages/volume_control.h>
#include <stages/limiter_rms.h>
#include <pipeline_config.h>
#include <dsp_thread_config.h>
#include <volume_control_config.h>
#include <limiter_rms_config.h>
DECLARE_JOB(dsp_auto_thread0, (chanend_t*, chanend_t*, module_instance_t**));
void dsp_auto_thread0(chanend_t* c_source, chanend_t* c_dest, module_instance_t** modules) {
	local_thread_mode_set_bits(thread_mode_high_priority);	int32_t edge0[1] = {0};
	int32_t edge1[1] = {0};
	int32_t edge2[1] = {0};
	int32_t edge3[1] = {0};
	int32_t edge4[1] = {0};
	int32_t edge5[1] = {0};
	int32_t edge6[1] = {0};
	int32_t edge7[1] = {0};
	int32_t edge8[1] = {0};
	int32_t edge9[1] = {0};
	int32_t edge10[1] = {0};
	int32_t edge11[1] = {0};
	int32_t* stage_2_input[] = {edge0, edge1, edge2, edge3};
	int32_t* stage_2_output[] = {edge4, edge5, edge6, edge7};
	int32_t* stage_3_input[] = {edge4, edge5, edge6, edge7};
	int32_t* stage_3_output[] = {edge8, edge9, edge10, edge11};
	uint32_t start_ts, end_ts, start_control_ts, control_ticks;
	bool control_done;
	while(1) {
	control_done = false;
	int read_count = 1;
	SELECT_RES(
		CASE_THEN(c_source[0], case_0),
		DEFAULT_THEN(do_control)
	) {
		case_0: {
			chan_in_buf_word(c_source[0], (uint32_t*)edge0, 1); for(int idx = 0; idx < 1; ++idx) edge0[idx] = adsp_from_q31(edge0[idx]);
			chan_in_buf_word(c_source[0], (uint32_t*)edge1, 1); for(int idx = 0; idx < 1; ++idx) edge1[idx] = adsp_from_q31(edge1[idx]);
			chan_in_buf_word(c_source[0], (uint32_t*)edge2, 1); for(int idx = 0; idx < 1; ++idx) edge2[idx] = adsp_from_q31(edge2[idx]);
			chan_in_buf_word(c_source[0], (uint32_t*)edge3, 1); for(int idx = 0; idx < 1; ++idx) edge3[idx] = adsp_from_q31(edge3[idx]);
			if(!--read_count) break;
			else continue;
		}
		do_control: {
		start_control_ts = get_reference_time();
		pipeline_control(modules[0]->state, &modules[0]->control);
		dsp_thread_control(modules[1]->state, &modules[1]->control);
		volume_control_control(modules[2]->state, &modules[2]->control);
		limiter_rms_control(modules[3]->state, &modules[3]->control);
		control_done = true;
		control_ticks = get_reference_time() - start_control_ts;
		continue; }
	}
	if(!control_done){
		start_control_ts = get_reference_time();
		pipeline_control(modules[0]->state, &modules[0]->control);
		dsp_thread_control(modules[1]->state, &modules[1]->control);
		volume_control_control(modules[2]->state, &modules[2]->control);
		limiter_rms_control(modules[3]->state, &modules[3]->control);
		control_ticks = get_reference_time() - start_control_ts;
	}
	start_ts = get_reference_time();

	volume_control_process(
		stage_2_input,
		stage_2_output,
		modules[2]->state);
	limiter_rms_process(
		stage_3_input,
		stage_3_output,
		modules[3]->state);

	end_ts = get_reference_time();
	uint32_t process_plus_control_ticks = (end_ts - start_ts) + control_ticks;
	if(process_plus_control_ticks > ((dsp_thread_state_t*)(modules[1]->state))->max_cycles)
	{
		((dsp_thread_state_t*)(modules[1]->state))->max_cycles = process_plus_control_ticks;
	}
	for(int idx = 0; idx < 1; ++idx) edge8[idx] = adsp_to_q31(edge8[idx]); chan_out_buf_word(c_dest[0], (uint32_t*)edge8, 1);
	for(int idx = 0; idx < 1; ++idx) edge9[idx] = adsp_to_q31(edge9[idx]); chan_out_buf_word(c_dest[0], (uint32_t*)edge9, 1);
	for(int idx = 0; idx < 1; ++idx) edge10[idx] = adsp_to_q31(edge10[idx]); chan_out_buf_word(c_dest[0], (uint32_t*)edge10, 1);
	for(int idx = 0; idx < 1; ++idx) edge11[idx] = adsp_to_q31(edge11[idx]); chan_out_buf_word(c_dest[0], (uint32_t*)edge11, 1);
	}
}
adsp_pipeline_t * adsp_auto_pipeline_init() {
	static adsp_pipeline_t adsp_auto;
	static adsp_controller_t adsp_auto_controller;
	m_control = &adsp_auto_controller;
	static channel_t adsp_auto_in_chans[1];
	static channel_t adsp_auto_out_chans[1];
	static channel_t adsp_auto_link_chans[0];
	static module_instance_t adsp_auto_modules[4];
	static adsp_mux_elem_t adsp_auto_in_mux_cfgs[] = {
		{ .channel_idx = 0, .data_idx = 0, .frame_size = 1},
		{ .channel_idx = 0, .data_idx = 1, .frame_size = 1},
		{ .channel_idx = 0, .data_idx = 2, .frame_size = 1},
		{ .channel_idx = 0, .data_idx = 3, .frame_size = 1},
	};
	static adsp_mux_elem_t adsp_auto_out_mux_cfgs[] = {
		{ .channel_idx = 0, .data_idx = 0, .frame_size = 1},
		{ .channel_idx = 0, .data_idx = 1, .frame_size = 1},
		{ .channel_idx = 0, .data_idx = 2, .frame_size = 1},
		{ .channel_idx = 0, .data_idx = 3, .frame_size = 1},
	};
	adsp_auto.input_mux.n_chan = 4;
	adsp_auto.input_mux.chan_cfg = (adsp_mux_elem_t *) adsp_auto_in_mux_cfgs;
	adsp_auto.output_mux.n_chan = 4;
	adsp_auto.output_mux.chan_cfg = (adsp_mux_elem_t *) adsp_auto_out_mux_cfgs;
	adsp_auto_in_chans[0] = chan_alloc();
	adsp_auto_out_chans[0] = chan_alloc();
	adsp_auto.p_in = (channel_t *) adsp_auto_in_chans;
	adsp_auto.n_in = 1;
	adsp_auto.p_out = (channel_t *) adsp_auto_out_chans;
	adsp_auto.n_out = 1;
	adsp_auto.p_link = (channel_t *) adsp_auto_link_chans;
	adsp_auto.n_link = 0;
	adsp_auto.modules = adsp_auto_modules;
	adsp_auto.n_modules = 4;
	static pipeline_config_t config0 = { .checksum = {175, 191, 83, 30, 108, 96, 218, 136, 116, 30, 247, 175, 107, 144, 213, 118} };

            static pipeline_state_t state0;
            static uint8_t memory0[PIPELINE_STAGE_REQUIRED_MEMORY];
            static adsp_bump_allocator_t allocator0 = ADSP_BUMP_ALLOCATOR_INITIALISER(memory0);

            adsp_auto.modules[0].state = (void*)&state0;

            // Control stuff
            adsp_auto.modules[0].control.id = 0;
            adsp_auto.modules[0].control.config_rw_state = config_none_pending;
            
                adsp_auto.modules[0].control.config = (void*)&config0;
                adsp_auto.modules[0].control.module_type = e_dsp_stage_pipeline;
                adsp_auto.modules[0].control.num_control_commands = NUM_CMDS_PIPELINE;
                pipeline_init(&adsp_auto.modules[0], &allocator0, 0, 0, 0, 1);
	static dsp_thread_config_t config1 = {  };

            static dsp_thread_state_t state1;
            static uint8_t memory1[DSP_THREAD_STAGE_REQUIRED_MEMORY];
            static adsp_bump_allocator_t allocator1 = ADSP_BUMP_ALLOCATOR_INITIALISER(memory1);

            adsp_auto.modules[1].state = (void*)&state1;

            // Control stuff
            adsp_auto.modules[1].control.id = 1;
            adsp_auto.modules[1].control.config_rw_state = config_none_pending;
            
                adsp_auto.modules[1].control.config = (void*)&config1;
                adsp_auto.modules[1].control.module_type = e_dsp_stage_dsp_thread;
                adsp_auto.modules[1].control.num_control_commands = NUM_CMDS_DSP_THREAD;
                dsp_thread_init(&adsp_auto.modules[1], &allocator1, 1, 0, 0, 1);
	static volume_control_config_t config2 = { .target_gain = 134217728, .slew_shift = 7, .mute_state = 0 };

            static volume_control_state_t state2;
            static uint8_t memory2[VOLUME_CONTROL_STAGE_REQUIRED_MEMORY(4)];
            static adsp_bump_allocator_t allocator2 = ADSP_BUMP_ALLOCATOR_INITIALISER(memory2);

            adsp_auto.modules[2].state = (void*)&state2;

            // Control stuff
            adsp_auto.modules[2].control.id = 2;
            adsp_auto.modules[2].control.config_rw_state = config_none_pending;
            
                adsp_auto.modules[2].control.config = (void*)&config2;
                adsp_auto.modules[2].control.module_type = e_dsp_stage_volume_control;
                adsp_auto.modules[2].control.num_control_commands = NUM_CMDS_VOLUME_CONTROL;
                volume_control_init(&adsp_auto.modules[2], &allocator2, 2, 4, 4, 1);
	static limiter_rms_config_t config3 = { .attack_alpha = 8947849, .release_alpha = 447392, .threshold = 134217728 };

            static limiter_rms_state_t state3;
            static uint8_t memory3[LIMITER_RMS_STAGE_REQUIRED_MEMORY(4)];
            static adsp_bump_allocator_t allocator3 = ADSP_BUMP_ALLOCATOR_INITIALISER(memory3);

            adsp_auto.modules[3].state = (void*)&state3;

            // Control stuff
            adsp_auto.modules[3].control.id = 3;
            adsp_auto.modules[3].control.config_rw_state = config_none_pending;
            
                adsp_auto.modules[3].control.config = (void*)&config3;
                adsp_auto.modules[3].control.module_type = e_dsp_stage_limiter_rms;
                adsp_auto.modules[3].control.num_control_commands = NUM_CMDS_LIMITER_RMS;
                limiter_rms_init(&adsp_auto.modules[3], &allocator3, 3, 4, 4, 1);
	adsp_controller_init(&adsp_auto_controller, &adsp_auto);
	return &adsp_auto;
}


#include "adsp_instance_id_auto.h"
#include <stdio.h>

static void do_read(int instance, int cmd_id, int size, void* data) {
    adsp_stage_control_cmd_t cmd = {
        .instance_id = instance,
        .cmd_id = cmd_id,
        .payload_len = size,
        .payload = data
    };
    xassert(m_control);
    for(;;) {
        adsp_control_status_t ret = adsp_read_module_config(
                m_control,
                &cmd);
        if(ADSP_CONTROL_SUCCESS == ret) {
            return;
        }
    }
}

void adsp_auto_print_thread_max_ticks(void) {
    int thread_ticks[1];
    do_read(thread0_stage_index, CMD_DSP_THREAD_MAX_CYCLES, sizeof(int), &thread_ticks[0]);
    printf("DSP Thread Ticks:\n0:\t%d\n", thread_ticks[0]);
}
void adsp_auto_pipeline_main(adsp_pipeline_t* adsp) {
	module_instance_t* thread_0_modules[] = {
		&adsp->modules[0],
		&adsp->modules[1],
		&adsp->modules[2],
		&adsp->modules[3],
	};
	chanend_t thread_0_inputs[] = {
		adsp->p_in[0].end_b};
	chanend_t thread_0_outputs[] = {
		adsp->p_out[0].end_a};
	PAR_JOBS(
		PJOB(dsp_auto_thread0, (thread_0_inputs, thread_0_outputs, thread_0_modules))
	);
}
