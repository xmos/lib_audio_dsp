// Copyright 2022-2024 XMOS LIMITED.
// This Software is subject to the terms of the XMOS Public Licence: Version 1.
#include <stdlib.h>
#include <inttypes.h>
#include <string>

#include <iomanip>
#include <cstring>
#include <cstdint>
#include <iostream>
#include <map>
#include <cmath>

// To avoid including device_control_shared
typedef uint8_t control_resid_t;
typedef uint8_t control_cmd_t;

// The enum and structs defined below are duplicated here and in the host app. When modifying, make sure that the ones in host app are modified as well.
/** @brief Enum for read/write command types */
enum cmd_rw_t {CMD_READ_ONLY, CMD_WRITE_ONLY, CMD_READ_WRITE};

/**
 * @brief Enum for supported param types
 *
 * @note Add new cmd_param_type's to the end of the list.
 * @note TYPE_CHAR can only be READ ONLY.
 */
enum cmd_param_type_t {TYPE_CHAR, TYPE_UINT8, TYPE_INT32, TYPE_FLOAT, TYPE_UINT32, TYPE_RADIANS};

/** @brief Union for supporting different command param types */
union cmd_param_t {uint8_t ui8; int32_t i32; float f; uint32_t ui32;};

struct cmd_t {
    // Command resource ID
    control_resid_t res_id;
    // Command name
    std::string cmd_name;
    // Command value type
    cmd_param_type_t type;
    // Command ID
    control_cmd_t cmd_id;
    // Command read/write type
    cmd_rw_t rw;
    // Number of values command reads/writes
    unsigned num_values;
    // Command info
    std::string info;
   /** Command visibility status */
    bool hidden_cmd;
    //
};

#include "host_cmd_map.h" // Autogenerated file that contains the host command map

static size_t num_commands = std::end(commands) - std::begin(commands);

extern "C"
size_t get_cmd_index(const std::string cmd_name)
{
    size_t index = UINT32_MAX;
    for(size_t i = 0; i < num_commands; i++)
    {
        cmd_t * cmd = &commands[i];
        if (cmd_name == cmd->cmd_name)
        {
            index = i;
            break;
        }
    }
    return index;
}

extern "C"
std::string get_cmd_name(const size_t index)
{
    return commands[index].cmd_name;
}

extern "C"
void get_cmd_id_info(control_resid_t * res_id, control_cmd_t * cmd_id, const size_t index)
{
    *res_id = commands[index].res_id;
    *cmd_id = commands[index].cmd_id;
}

extern "C"
void get_cmd_val_info(cmd_param_type_t * type, cmd_rw_t * rw, unsigned * num_vals, const size_t index)
{

    *type = commands[index].type;
    *rw = commands[index].rw;
    *num_vals = commands[index].num_values;
}

extern "C"
std::string get_cmd_info(const size_t index)
{
    return commands[index].info;
}

extern "C"
bool get_cmd_hidden(const size_t index)
{
    return commands[index].hidden_cmd;
}

extern "C"
uint32_t get_num_commands()
{
    return num_commands;
}

static int i2c_info = 0x2C;    // I2C slave address

static int spi_info[2] = {
    0,                  // SPI_MODE
    1024                // clock divider
};

static int usb_info[3] = {
    0x20b1,  // vendor ID
    0x5000, // product ID
    3           // control interface number
};

extern "C"
int * get_info_i2c()
{
    return &i2c_info;
}

extern "C"
int * get_info_spi()
{
    return spi_info;
}

extern "C"
int * get_info_usb()
{
    return usb_info;
}

void print_arg_local(const cmd_param_type_t type, const cmd_param_t val)
{
    switch(type)
    {
    case TYPE_CHAR:
        std::cout << static_cast<char>(val.ui8);
        break;
    case TYPE_UINT8:
        std::cout << static_cast<int>(val.ui8) << " ";
        break;
    case TYPE_FLOAT:
        std::cout << std::setprecision(7) << val.f << " ";
        break;
    case TYPE_RADIANS:
        std::cout << std::setprecision(5) << std::fixed << val.f << std::setprecision(2) << std::fixed << " (" << val.f  * 180.0f / M_PI << " deg)" << " ";
        break;
    case TYPE_INT32:
        std::cout << val.i32 << " ";
        break;
    case TYPE_UINT32:
        std::cout << val.ui32 << " ";
        break;
    default:
        std::cerr << "Unsupported parameter type" << std::endl;
        exit(-1);
    }
}
